// This code is from Unique and Valid MAC Address Generator  by Jay Jay
// https://www.ghielectronics.com/community/codeshare/entry/822

using System;
using Microsoft.SPOT;

namespace RoSchmi.Net.Divers
{
    static class GenerateUniqueMacAddr
    {
        /// <summary>
        /// Generates a Unique MAC Address based on a a hashcode
        /// 
        /// </summary>
        /// <param name="myUniqueId"></param>
        /// <returns></returns>
        public static byte[] GenerateUniqueMacAddress(object myUniqueId = null)
        {
            //great article explaining the making of the MAC Address first Byte...
            //http://packetsdropped.wordpress.com/2011/01/13/mac-address-universally-or-locally-administered-bit-and-individualgroup-bit/

            // create a en empty byte array
            var myMac = new byte[6];
            //generate a random based on a fixed seed this will guarantee that we get the 
            //same Random number everytime based on the provided string... make your string UNIQUE...
            //This would be great if only each board had a UNIQUE SERIAL NUmber ahhhhhh...          
            var r = myUniqueId != null ? new Random(myUniqueId.GetHashCode()) : new Random();
            // fill the newly generated bytes into the variable
            r.NextBytes(myMac);
            // update the last bit of the first byte with 1 which will flg the Mac as a Locally administered Mac address...
            //Please share if you have a better way of doing this.
            myMac[0] = (byte)(myMac[0] | 0x01);
            //shift to the left by 1 which will give 10 on the last two bits of the first byte... 0 on the last bit means UNICAST Mac Address.
            myMac[0] = (byte)(myMac[0] << 1);
            return myMac;
        }
        //returns true if the two byte arrays are equal
        public static bool ByteArrayEquals(byte[] a1, byte[] a2)
        {
            if (a1 == a2)
            {
                return true;
            }
            if ((a1 != null) && (a2 != null))
            {
                if (a1.Length != a2.Length)
                {
                    return false;
                }
                for (int i = 0; i < a1.Length; i++)
                {
                    if (a1[i] != a2[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }


    }
}
